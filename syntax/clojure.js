KateSyntax.langs.clojure.syntax = {
    default: 'clojure_level0',
    clojure_level0: function clojure_level0(m) {
        this.push();
        while(this.pos < this.len) {
            if(this.str[0] == '(' && this.hl('(', 'dsNormal;color:#ff0000;fontStyle:normal;fontWeight:normal')) {if(m = this.clojure_level1())return this.pop(), m-1;continue;}
            if(this.str[0] == '#' && this.str[1] == '(' && this.hl('#(', 'dsNormal;color:#ff0000;fontStyle:normal;fontWeight:normal')) {if(m = this.clojure_level1())return this.pop(), m-1;continue;}
            if((m = /^;.*(?=$|\n)/.exec(this.str)) && this.hl(m[0], 'dsComment')) continue;
            if(this.str[0] == '#' && this.str[1] == '_' && this.hl('#_', 'dsComment')) continue;
            if((m = /^[@~]\S+/.exec(this.str)) && this.hl(m[0], 'dsKeyword;color:#800000')) continue;
            if((m = /^::?[a-zA-Z0-9\-]+/.exec(this.str)) && this.hl(m[0], 'dsKeyword;color:#555555')) continue;
            if(this.str[0] == '#' && this.str[1] == '{' && this.hl('#{', 'dsNormal;color:#0000ff;fontStyle:normal;fontWeight:bold')) continue;
            if(this.str[0] == '^' && this.str[1] == '{' && this.hl('^{', 'dsNormal;color:#0000ff;fontStyle:normal;fontWeight:bold')) continue;
            if(this.str[0] == '{' && this.hl('{', 'dsNormal;color:#206620')) continue;
            if(this.str[0] == '}' && this.hl('}', 'dsNormal;color:#206620')) continue;
            if(this.str[0] == '[' && this.hl('[', 'dsNormal;color:#3333ff')) continue;
            if(this.str[0] == ']' && this.hl(']', 'dsNormal;color:#3333ff')) continue;
            if(this.str[0] == '#' && this.str[1] == '\'' && this.hl('#\'', 'dsKeyword;color:#b07e1f')) continue;
            if((m = /^(?:<|<=|=|==|>|>=|-|->|->>|\/|\.|\.\.|\*|\+|accessor|aclone|add-classpath|add-watcher|agent|agent-errors|aget|alength|alias|all-ns|alter|alter-meta!|alter-var-root|amap|ancestors|and|append-child|apply|apply-template|are|areduce|array-map|aset|aset-boolean|aset-byte|aset-char|aset-double|aset-float|aset-int|aset-long|aset-short|assert|assert-any|assert-expr|assert-predicate|assoc|assoc!|associative\?|assoc-in|atom|atom\?|attrs|await|await1|await-for|bases|bean|bigdec|bigint|binding|bit-and|bit-and-not|bit-clear|bit-flip|bit-not|bit-or|bit-set|bit-shift-left|bit-shift-right|bit-test|bit-xor|boolean|boolean-array|booleans|bound-fn|bound-fn\*|branch\?|butlast|byte|byte-array|bytes|case|cast|catch|char|char\?|char-array|char-escape-string|char-name-string|chars|children|chunk|chunk-append|chunk-buffer|chunk-cons|chunked-seq\?|chunk-first|chunk-next|chunk-rest|class|class\?|clear-agent-errors|clojure-version|coll\?|collection-tag|comment|commute|comp|comparator|compare|compare-and-set!|compile|complement|compose-fixtures|concat|cond|condp|conj|conj!|cons|constantly|construct-proxy|contains\?|content|content-handler|count|counted\?|create-ns|create-struct|cycle|dec|decimal\?|declare|delay|delay\?|deliver|deref|derive|descendants|destructure|difference|disj|disj!|dissoc|dissoc!|distinct|distinct\?|do|doall|doc|dorun|doseq|dosync|do-template|dotimes|doto|double|double-array|doubles|down|drop|drop-last|drop-while|e|edit|element|emit|emit-element|empty|empty\?|end\?|ensure|enumeration-seq|eval|even\?|every\?|extend|extenders|extend-protocol|extends\?|extend-type|false\?|ffirst|file-position|file-seq|filter|finally|find|find-doc|find-ns|find-var|first|float|float\?|float-array|floats|flush|fn|fn\?|fnext|for|force|format|function\?|future|future\?|future-call|future-cancel|future-cancelled\?|future-done\?|gen-and-load-class|gen-and-save-class|gen-class|gen-interface|gensym|get|get-child|get-child-count|get-in|get-method|get-possibly-unbound-var|get-proxy-class|get-thread-bindings|get-validator|handle|handler-case|hash|hash-map|hash-set|identical\?|identity|if|if-let|ifn\?|if-not|import|inc|inc-report-counter|index|init-proxy|in-ns|insert-child|insert-left|insert-right|inspect|inspect-table|inspect-tree|instance\?|int|int-array|integer\?|interleave|intern|interpose|intersection|into|into-array|ints|io!|is|isa\?|is-leaf|iterate|iterator-seq|join|join-fixtures|juxt|key|keys|keyword|keyword\?|keywordize-keys|last|lazy-cat|lazy-seq|left|leftmost|lefts|let|letfn|line-seq|list|list\*|list\?|list-model|list-provider|load|loaded-libs|load-file|load-reader|load-script|load-string|locking|long|long-array|longs|loop|macroexpand|macroexpand-1|macroexpand-all|main|make-array|make-hierarchy|make-node|map|map\?|mapcat|map-invert|max|max-key|memfn|memoize|merge|merge-with|meta|methods|method-sig|min|min-key|mod|name|namespace|neg\?|newline|next|nfirst|nil\?|nnext|node|not|not=|not-any\?|not-empty|not-every\?|ns|ns-aliases|ns-imports|ns-interns|ns-map|ns-name|ns-publics|ns-refers|ns-resolve|ns-unalias|ns-unmap|nth|nthnext|num|number\?|odd\?|or|parents|partial|partition|path|pcalls|peek|persistent!|pmap|pop|pop!|pop-thread-bindings|pos\?|postwalk|postwalk-demo|postwalk-replace|pr|prefer-method|prefers|prev|prewalk|prewalk-demo|prewalk-replace|primitives-classnames|print|print-cause-trace|print-ctor|print-doc|print-dup|printf|println|println-str|print-method|print-namespace-doc|print-simple|print-special-doc|print-stack-trace|print-str|print-throwable|print-trace-element|prn|prn-str|project|promise|proxy|proxy-call-with-super|proxy-mappings|proxy-name|proxy-super|pr-str|push-thread-bindings|pvalues|quot|rand|rand-int|range|ratio\?|rational\?|rationalize|read|read-line|read-string|recur|reduce|ref|refer|refer-clojure|ref-history-count|re-find|ref-max-history|ref-min-history|ref-set|re-groups|reify|release-pending-sends|rem|re-matcher|re-matches|remove|remove-method|remove-ns|remove-watcher|rename|rename-keys|re-pattern|repeat|repeatedly|repl|replace|repl-caught|repl-exception|replicate|repl-prompt|repl-read|report|require|re-seq|reset!|reset-meta!|resolve|rest|resultset-seq|reverse|reversible\?|right|rightmost|rights|root|rseq|rsubseq|run-all-tests|run-tests|satisfies\?|second|select|select-keys|send|send-off|seq|seq\?|seque|sequence|sequential\?|seq-zip|set|set\?|set-test|set-validator!|short|short-array|shorts|shutdown-agents|skip-if-eol|skip-whitespace|slurp|some|sort|sort-by|sorted\?|sorted-map|sorted-map-by|sorted-set|sorted-set-by|special-form-anchor|special-symbol\?|split-at|split-with|str|stream\?|string\?|stringify-keys|struct|struct-map|subs|subseq|subvec|successful\?|supers|swap!|symbol|symbol\?|sync|syntax-symbol-anchor|take|take-last|take-nth|take-while|test|test-all-vars|testing|testing-contexts-str|testing-vars-str|test-ns|test-var|the-ns|throw|time|to-array|to-array-2d|trampoline|transient|tree-seq|true\?|try|try-expr|type|unchecked-add|unchecked-dec|unchecked-divide|unchecked-inc|unchecked-multiply|unchecked-negate|unchecked-remainder|unchecked-subtract|underive|unimport|union|unquote|unquote-splicing|up|update-in|update-proxy|use|use-fixtures|val|vals|var\?|var-get|var-set|vary-meta|vec|vector|vector\?|walk|when|when-first|when-let|when-not|while|with-bindings|with-bindings\*|with-in-str|with-loading-context|with-local-vars|with-meta|with-open|with-out-str|with-precision|with-test|with-test-out|xml-seq|zero\?)\b/.exec(this.str)) && this.hl(m[0], 'dsKeyword')) continue;
            if((m = /^(?:\*1|\*2|\*3|\*agent\*|\*allow-unresolved-vars\*|\*assert\*|\*clojure-version\*|\*command-line-args\*|\*compile-files\*|\*compile-path\*|\*current\*|\*e|\*err\*|\*file\*|\*flush-on-newline\*|\*in\*|\*initial-report-counters\*|\*load-tests\*|\*macro-meta\*|\*math-context\*|\*ns\*|\*out\*|\*print-dup\*|\*print-length\*|\*print-level\*|\*print-meta\*|\*print-readably\*|\*read-eval\*|\*report-counters\*|\*sb\*|\*source-path\*|\*stack\*|\*stack-trace-depth\*|\*state\*|\*testing-contexts\*|\*testing-vars\*|\*test-out\*|\*use-context-classloader\*|\*warn-on-reflection\*)\b/.exec(this.str)) && this.hl(m[0], 'dsKeyword;color:#b07e1f')) continue;
            if((m = /^(?:def|def-|defalias|defhinted|definline|defmacro|defmacro-|defmethod|defmulti|defn|defn-|defnk|defn-memo|defonce|defonce-|defprotocol|defrecord|defstruct|defstruct-|deftest|deftest-|deftype|defunbound|defunbound-|defvar|defvar-)\b/.exec(this.str)) && this.hl(m[0], 'dsKeyword;color:#d22811')) {if(m = this.clojure_function_decl())return this.pop(), m-1;continue;}
            if((m = /^\\./.exec(this.str)) && this.hl(m[0], 'dsChar')) continue;
            if(this.str[0] == '#' && this.str[1] == '"' && this.hl('#"', 'dsString')) {if(m = this.clojure_string())return this.pop(), m-1;continue;}
            if(this.str[0] == '"' && this.hl('"', 'dsString')) {if(m = this.clojure_string())return this.pop(), m-1;continue;}
            if((m = /^\d*\.\d+/.exec(this.str)) && this.hl(m[0], 'dsFloat')) continue;
            if((m = /^\d+/.exec(this.str)) && this.hl(m[0], 'dsDecVal')) continue;
            if(this.str[0] == '(' && this.hl('(', 'dsNormal;color:#ff0000;fontStyle:normal;fontWeight:normal')) {if(m = this.clojure_level1())return this.pop(), m-1;continue;}
            this.hl(this.str[0], 'dsNormal');
        }
        this.pop();
    },
    clojure_default: function clojure_default(m) {
        this.push();
        while(this.pos < this.len) {
            if((m = /^;.*(?=$|\n)/.exec(this.str)) && this.hl(m[0], 'dsComment')) continue;
            if(this.str[0] == '#' && this.str[1] == '_' && this.hl('#_', 'dsComment')) continue;
            if((m = /^[@~]\S+/.exec(this.str)) && this.hl(m[0], 'dsKeyword;color:#800000')) continue;
            if((m = /^::?[a-zA-Z0-9\-]+/.exec(this.str)) && this.hl(m[0], 'dsKeyword;color:#555555')) continue;
            if(this.str[0] == '#' && this.str[1] == '{' && this.hl('#{', 'dsNormal;color:#0000ff;fontStyle:normal;fontWeight:bold')) continue;
            if(this.str[0] == '^' && this.str[1] == '{' && this.hl('^{', 'dsNormal;color:#0000ff;fontStyle:normal;fontWeight:bold')) continue;
            if(this.str[0] == '{' && this.hl('{', 'dsNormal;color:#206620')) continue;
            if(this.str[0] == '}' && this.hl('}', 'dsNormal;color:#206620')) continue;
            if(this.str[0] == '[' && this.hl('[', 'dsNormal;color:#3333ff')) continue;
            if(this.str[0] == ']' && this.hl(']', 'dsNormal;color:#3333ff')) continue;
            if(this.str[0] == '#' && this.str[1] == '\'' && this.hl('#\'', 'dsKeyword;color:#b07e1f')) continue;
            if((m = /^(?:<|<=|=|==|>|>=|-|->|->>|\/|\.|\.\.|\*|\+|accessor|aclone|add-classpath|add-watcher|agent|agent-errors|aget|alength|alias|all-ns|alter|alter-meta!|alter-var-root|amap|ancestors|and|append-child|apply|apply-template|are|areduce|array-map|aset|aset-boolean|aset-byte|aset-char|aset-double|aset-float|aset-int|aset-long|aset-short|assert|assert-any|assert-expr|assert-predicate|assoc|assoc!|associative\?|assoc-in|atom|atom\?|attrs|await|await1|await-for|bases|bean|bigdec|bigint|binding|bit-and|bit-and-not|bit-clear|bit-flip|bit-not|bit-or|bit-set|bit-shift-left|bit-shift-right|bit-test|bit-xor|boolean|boolean-array|booleans|bound-fn|bound-fn\*|branch\?|butlast|byte|byte-array|bytes|case|cast|catch|char|char\?|char-array|char-escape-string|char-name-string|chars|children|chunk|chunk-append|chunk-buffer|chunk-cons|chunked-seq\?|chunk-first|chunk-next|chunk-rest|class|class\?|clear-agent-errors|clojure-version|coll\?|collection-tag|comment|commute|comp|comparator|compare|compare-and-set!|compile|complement|compose-fixtures|concat|cond|condp|conj|conj!|cons|constantly|construct-proxy|contains\?|content|content-handler|count|counted\?|create-ns|create-struct|cycle|dec|decimal\?|declare|delay|delay\?|deliver|deref|derive|descendants|destructure|difference|disj|disj!|dissoc|dissoc!|distinct|distinct\?|do|doall|doc|dorun|doseq|dosync|do-template|dotimes|doto|double|double-array|doubles|down|drop|drop-last|drop-while|e|edit|element|emit|emit-element|empty|empty\?|end\?|ensure|enumeration-seq|eval|even\?|every\?|extend|extenders|extend-protocol|extends\?|extend-type|false\?|ffirst|file-position|file-seq|filter|finally|find|find-doc|find-ns|find-var|first|float|float\?|float-array|floats|flush|fn|fn\?|fnext|for|force|format|function\?|future|future\?|future-call|future-cancel|future-cancelled\?|future-done\?|gen-and-load-class|gen-and-save-class|gen-class|gen-interface|gensym|get|get-child|get-child-count|get-in|get-method|get-possibly-unbound-var|get-proxy-class|get-thread-bindings|get-validator|handle|handler-case|hash|hash-map|hash-set|identical\?|identity|if|if-let|ifn\?|if-not|import|inc|inc-report-counter|index|init-proxy|in-ns|insert-child|insert-left|insert-right|inspect|inspect-table|inspect-tree|instance\?|int|int-array|integer\?|interleave|intern|interpose|intersection|into|into-array|ints|io!|is|isa\?|is-leaf|iterate|iterator-seq|join|join-fixtures|juxt|key|keys|keyword|keyword\?|keywordize-keys|last|lazy-cat|lazy-seq|left|leftmost|lefts|let|letfn|line-seq|list|list\*|list\?|list-model|list-provider|load|loaded-libs|load-file|load-reader|load-script|load-string|locking|long|long-array|longs|loop|macroexpand|macroexpand-1|macroexpand-all|main|make-array|make-hierarchy|make-node|map|map\?|mapcat|map-invert|max|max-key|memfn|memoize|merge|merge-with|meta|methods|method-sig|min|min-key|mod|name|namespace|neg\?|newline|next|nfirst|nil\?|nnext|node|not|not=|not-any\?|not-empty|not-every\?|ns|ns-aliases|ns-imports|ns-interns|ns-map|ns-name|ns-publics|ns-refers|ns-resolve|ns-unalias|ns-unmap|nth|nthnext|num|number\?|odd\?|or|parents|partial|partition|path|pcalls|peek|persistent!|pmap|pop|pop!|pop-thread-bindings|pos\?|postwalk|postwalk-demo|postwalk-replace|pr|prefer-method|prefers|prev|prewalk|prewalk-demo|prewalk-replace|primitives-classnames|print|print-cause-trace|print-ctor|print-doc|print-dup|printf|println|println-str|print-method|print-namespace-doc|print-simple|print-special-doc|print-stack-trace|print-str|print-throwable|print-trace-element|prn|prn-str|project|promise|proxy|proxy-call-with-super|proxy-mappings|proxy-name|proxy-super|pr-str|push-thread-bindings|pvalues|quot|rand|rand-int|range|ratio\?|rational\?|rationalize|read|read-line|read-string|recur|reduce|ref|refer|refer-clojure|ref-history-count|re-find|ref-max-history|ref-min-history|ref-set|re-groups|reify|release-pending-sends|rem|re-matcher|re-matches|remove|remove-method|remove-ns|remove-watcher|rename|rename-keys|re-pattern|repeat|repeatedly|repl|replace|repl-caught|repl-exception|replicate|repl-prompt|repl-read|report|require|re-seq|reset!|reset-meta!|resolve|rest|resultset-seq|reverse|reversible\?|right|rightmost|rights|root|rseq|rsubseq|run-all-tests|run-tests|satisfies\?|second|select|select-keys|send|send-off|seq|seq\?|seque|sequence|sequential\?|seq-zip|set|set\?|set-test|set-validator!|short|short-array|shorts|shutdown-agents|skip-if-eol|skip-whitespace|slurp|some|sort|sort-by|sorted\?|sorted-map|sorted-map-by|sorted-set|sorted-set-by|special-form-anchor|special-symbol\?|split-at|split-with|str|stream\?|string\?|stringify-keys|struct|struct-map|subs|subseq|subvec|successful\?|supers|swap!|symbol|symbol\?|sync|syntax-symbol-anchor|take|take-last|take-nth|take-while|test|test-all-vars|testing|testing-contexts-str|testing-vars-str|test-ns|test-var|the-ns|throw|time|to-array|to-array-2d|trampoline|transient|tree-seq|true\?|try|try-expr|type|unchecked-add|unchecked-dec|unchecked-divide|unchecked-inc|unchecked-multiply|unchecked-negate|unchecked-remainder|unchecked-subtract|underive|unimport|union|unquote|unquote-splicing|up|update-in|update-proxy|use|use-fixtures|val|vals|var\?|var-get|var-set|vary-meta|vec|vector|vector\?|walk|when|when-first|when-let|when-not|while|with-bindings|with-bindings\*|with-in-str|with-loading-context|with-local-vars|with-meta|with-open|with-out-str|with-precision|with-test|with-test-out|xml-seq|zero\?)\b/.exec(this.str)) && this.hl(m[0], 'dsKeyword')) continue;
            if((m = /^(?:\*1|\*2|\*3|\*agent\*|\*allow-unresolved-vars\*|\*assert\*|\*clojure-version\*|\*command-line-args\*|\*compile-files\*|\*compile-path\*|\*current\*|\*e|\*err\*|\*file\*|\*flush-on-newline\*|\*in\*|\*initial-report-counters\*|\*load-tests\*|\*macro-meta\*|\*math-context\*|\*ns\*|\*out\*|\*print-dup\*|\*print-length\*|\*print-level\*|\*print-meta\*|\*print-readably\*|\*read-eval\*|\*report-counters\*|\*sb\*|\*source-path\*|\*stack\*|\*stack-trace-depth\*|\*state\*|\*testing-contexts\*|\*testing-vars\*|\*test-out\*|\*use-context-classloader\*|\*warn-on-reflection\*)\b/.exec(this.str)) && this.hl(m[0], 'dsKeyword;color:#b07e1f')) continue;
            if((m = /^(?:def|def-|defalias|defhinted|definline|defmacro|defmacro-|defmethod|defmulti|defn|defn-|defnk|defn-memo|defonce|defonce-|defprotocol|defrecord|defstruct|defstruct-|deftest|deftest-|deftype|defunbound|defunbound-|defvar|defvar-)\b/.exec(this.str)) && this.hl(m[0], 'dsKeyword;color:#d22811')) {if(m = this.clojure_function_decl())return this.pop(), m-1;continue;}
            if((m = /^\\./.exec(this.str)) && this.hl(m[0], 'dsChar')) continue;
            if(this.str[0] == '#' && this.str[1] == '"' && this.hl('#"', 'dsString')) {if(m = this.clojure_string())return this.pop(), m-1;continue;}
            if(this.str[0] == '"' && this.hl('"', 'dsString')) {if(m = this.clojure_string())return this.pop(), m-1;continue;}
            if((m = /^\d*\.\d+/.exec(this.str)) && this.hl(m[0], 'dsFloat')) continue;
            if((m = /^\d+/.exec(this.str)) && this.hl(m[0], 'dsDecVal')) continue;
            if(this.str[0] == '(' && this.hl('(', 'dsNormal;color:#ff0000;fontStyle:normal;fontWeight:normal')) {if(m = this.clojure_level1())return this.pop(), m-1;continue;}
            this.hl(this.str[0], 'dsNormal');
        }
        this.pop();
    },
    clojure_function_decl: function clojure_function_decl(m) {
        this.push();
        while(this.pos < this.len) {
            if((m = /^\s*[A-Za-z0-9-+\<\>//\*]*\s*/.exec(this.str)) && m[0].length && this.hl(m[0], 'dsFunction')) return this.pop();
            this.hl(this.str[0], 'dsFunction');
        }
        this.pop();
    },
    clojure_specialNumber: function clojure_specialNumber(m) {
        this.push();
        while(this.pos < this.len) {
            if((m = /^\d*\.\d+/.exec(this.str)) && this.hl(m[0], 'dsFloat')) return this.pop();
            if((m = /^\d+/.exec(this.str)) && this.hl(m[0], 'dsDecVal')) return this.pop();
            if((m = /^0[0-7]+/.exec(this.str)) && this.hl(m[0], 'dsBaseN')) return this.pop();
            if((m = /^0x[\da-fA-F]+/.exec(this.str)) && this.hl(m[0], 'dsFloat')) return this.pop();
            if(this.str[0] == '\n') return this.pop();
            this.hl(this.str[0], 'dsNormal');
        }
        this.pop();
    },
    clojure_string: function clojure_string(m) {
        this.push();
        while(this.pos < this.len) {
            if((m = /^#\\./.exec(this.str)) && this.hl(m[0], 'dsChar')) continue;
            if((m = /^\\([abefnrtv"'?\\]|x[\da-fA-F]{2}|0?[0-7]{1,2})/.exec(this.str)) && this.hl(m[0], 'dsString')) continue;
            if(this.str[0] == '"' && this.hl('"', 'dsString')) return this.pop();
            this.hl(this.str[0], 'dsString');
        }
        this.pop();
    },
    clojure_level1: function clojure_level1(m) {
        this.push();
        while(this.pos < this.len) {
            if(this.str[0] == '(' && this.hl('(', 'dsNormal;color:#ff8800;fontStyle:normal;fontWeight:normal')) {if(m = this.clojure_level2())return this.pop(), m-1;continue;}
            if(this.str[0] == '#' && this.str[1] == '(' && this.hl('#(', 'dsNormal;color:#ff8800;fontStyle:normal;fontWeight:normal')) {if(m = this.clojure_level2())return this.pop(), m-1;continue;}
            if(this.str[0] == ')' && this.hl(')', 'dsNormal;color:#ff0000;fontStyle:normal;fontWeight:normal')) return this.pop();
            if((m = /^;.*(?=$|\n)/.exec(this.str)) && this.hl(m[0], 'dsComment')) continue;
            if(this.str[0] == '#' && this.str[1] == '_' && this.hl('#_', 'dsComment')) continue;
            if((m = /^[@~]\S+/.exec(this.str)) && this.hl(m[0], 'dsKeyword;color:#800000')) continue;
            if((m = /^::?[a-zA-Z0-9\-]+/.exec(this.str)) && this.hl(m[0], 'dsKeyword;color:#555555')) continue;
            if(this.str[0] == '#' && this.str[1] == '{' && this.hl('#{', 'dsNormal;color:#0000ff;fontStyle:normal;fontWeight:bold')) continue;
            if(this.str[0] == '^' && this.str[1] == '{' && this.hl('^{', 'dsNormal;color:#0000ff;fontStyle:normal;fontWeight:bold')) continue;
            if(this.str[0] == '{' && this.hl('{', 'dsNormal;color:#206620')) continue;
            if(this.str[0] == '}' && this.hl('}', 'dsNormal;color:#206620')) continue;
            if(this.str[0] == '[' && this.hl('[', 'dsNormal;color:#3333ff')) continue;
            if(this.str[0] == ']' && this.hl(']', 'dsNormal;color:#3333ff')) continue;
            if(this.str[0] == '#' && this.str[1] == '\'' && this.hl('#\'', 'dsKeyword;color:#b07e1f')) continue;
            if((m = /^(?:<|<=|=|==|>|>=|-|->|->>|\/|\.|\.\.|\*|\+|accessor|aclone|add-classpath|add-watcher|agent|agent-errors|aget|alength|alias|all-ns|alter|alter-meta!|alter-var-root|amap|ancestors|and|append-child|apply|apply-template|are|areduce|array-map|aset|aset-boolean|aset-byte|aset-char|aset-double|aset-float|aset-int|aset-long|aset-short|assert|assert-any|assert-expr|assert-predicate|assoc|assoc!|associative\?|assoc-in|atom|atom\?|attrs|await|await1|await-for|bases|bean|bigdec|bigint|binding|bit-and|bit-and-not|bit-clear|bit-flip|bit-not|bit-or|bit-set|bit-shift-left|bit-shift-right|bit-test|bit-xor|boolean|boolean-array|booleans|bound-fn|bound-fn\*|branch\?|butlast|byte|byte-array|bytes|case|cast|catch|char|char\?|char-array|char-escape-string|char-name-string|chars|children|chunk|chunk-append|chunk-buffer|chunk-cons|chunked-seq\?|chunk-first|chunk-next|chunk-rest|class|class\?|clear-agent-errors|clojure-version|coll\?|collection-tag|comment|commute|comp|comparator|compare|compare-and-set!|compile|complement|compose-fixtures|concat|cond|condp|conj|conj!|cons|constantly|construct-proxy|contains\?|content|content-handler|count|counted\?|create-ns|create-struct|cycle|dec|decimal\?|declare|delay|delay\?|deliver|deref|derive|descendants|destructure|difference|disj|disj!|dissoc|dissoc!|distinct|distinct\?|do|doall|doc|dorun|doseq|dosync|do-template|dotimes|doto|double|double-array|doubles|down|drop|drop-last|drop-while|e|edit|element|emit|emit-element|empty|empty\?|end\?|ensure|enumeration-seq|eval|even\?|every\?|extend|extenders|extend-protocol|extends\?|extend-type|false\?|ffirst|file-position|file-seq|filter|finally|find|find-doc|find-ns|find-var|first|float|float\?|float-array|floats|flush|fn|fn\?|fnext|for|force|format|function\?|future|future\?|future-call|future-cancel|future-cancelled\?|future-done\?|gen-and-load-class|gen-and-save-class|gen-class|gen-interface|gensym|get|get-child|get-child-count|get-in|get-method|get-possibly-unbound-var|get-proxy-class|get-thread-bindings|get-validator|handle|handler-case|hash|hash-map|hash-set|identical\?|identity|if|if-let|ifn\?|if-not|import|inc|inc-report-counter|index|init-proxy|in-ns|insert-child|insert-left|insert-right|inspect|inspect-table|inspect-tree|instance\?|int|int-array|integer\?|interleave|intern|interpose|intersection|into|into-array|ints|io!|is|isa\?|is-leaf|iterate|iterator-seq|join|join-fixtures|juxt|key|keys|keyword|keyword\?|keywordize-keys|last|lazy-cat|lazy-seq|left|leftmost|lefts|let|letfn|line-seq|list|list\*|list\?|list-model|list-provider|load|loaded-libs|load-file|load-reader|load-script|load-string|locking|long|long-array|longs|loop|macroexpand|macroexpand-1|macroexpand-all|main|make-array|make-hierarchy|make-node|map|map\?|mapcat|map-invert|max|max-key|memfn|memoize|merge|merge-with|meta|methods|method-sig|min|min-key|mod|name|namespace|neg\?|newline|next|nfirst|nil\?|nnext|node|not|not=|not-any\?|not-empty|not-every\?|ns|ns-aliases|ns-imports|ns-interns|ns-map|ns-name|ns-publics|ns-refers|ns-resolve|ns-unalias|ns-unmap|nth|nthnext|num|number\?|odd\?|or|parents|partial|partition|path|pcalls|peek|persistent!|pmap|pop|pop!|pop-thread-bindings|pos\?|postwalk|postwalk-demo|postwalk-replace|pr|prefer-method|prefers|prev|prewalk|prewalk-demo|prewalk-replace|primitives-classnames|print|print-cause-trace|print-ctor|print-doc|print-dup|printf|println|println-str|print-method|print-namespace-doc|print-simple|print-special-doc|print-stack-trace|print-str|print-throwable|print-trace-element|prn|prn-str|project|promise|proxy|proxy-call-with-super|proxy-mappings|proxy-name|proxy-super|pr-str|push-thread-bindings|pvalues|quot|rand|rand-int|range|ratio\?|rational\?|rationalize|read|read-line|read-string|recur|reduce|ref|refer|refer-clojure|ref-history-count|re-find|ref-max-history|ref-min-history|ref-set|re-groups|reify|release-pending-sends|rem|re-matcher|re-matches|remove|remove-method|remove-ns|remove-watcher|rename|rename-keys|re-pattern|repeat|repeatedly|repl|replace|repl-caught|repl-exception|replicate|repl-prompt|repl-read|report|require|re-seq|reset!|reset-meta!|resolve|rest|resultset-seq|reverse|reversible\?|right|rightmost|rights|root|rseq|rsubseq|run-all-tests|run-tests|satisfies\?|second|select|select-keys|send|send-off|seq|seq\?|seque|sequence|sequential\?|seq-zip|set|set\?|set-test|set-validator!|short|short-array|shorts|shutdown-agents|skip-if-eol|skip-whitespace|slurp|some|sort|sort-by|sorted\?|sorted-map|sorted-map-by|sorted-set|sorted-set-by|special-form-anchor|special-symbol\?|split-at|split-with|str|stream\?|string\?|stringify-keys|struct|struct-map|subs|subseq|subvec|successful\?|supers|swap!|symbol|symbol\?|sync|syntax-symbol-anchor|take|take-last|take-nth|take-while|test|test-all-vars|testing|testing-contexts-str|testing-vars-str|test-ns|test-var|the-ns|throw|time|to-array|to-array-2d|trampoline|transient|tree-seq|true\?|try|try-expr|type|unchecked-add|unchecked-dec|unchecked-divide|unchecked-inc|unchecked-multiply|unchecked-negate|unchecked-remainder|unchecked-subtract|underive|unimport|union|unquote|unquote-splicing|up|update-in|update-proxy|use|use-fixtures|val|vals|var\?|var-get|var-set|vary-meta|vec|vector|vector\?|walk|when|when-first|when-let|when-not|while|with-bindings|with-bindings\*|with-in-str|with-loading-context|with-local-vars|with-meta|with-open|with-out-str|with-precision|with-test|with-test-out|xml-seq|zero\?)\b/.exec(this.str)) && this.hl(m[0], 'dsKeyword')) continue;
            if((m = /^(?:\*1|\*2|\*3|\*agent\*|\*allow-unresolved-vars\*|\*assert\*|\*clojure-version\*|\*command-line-args\*|\*compile-files\*|\*compile-path\*|\*current\*|\*e|\*err\*|\*file\*|\*flush-on-newline\*|\*in\*|\*initial-report-counters\*|\*load-tests\*|\*macro-meta\*|\*math-context\*|\*ns\*|\*out\*|\*print-dup\*|\*print-length\*|\*print-level\*|\*print-meta\*|\*print-readably\*|\*read-eval\*|\*report-counters\*|\*sb\*|\*source-path\*|\*stack\*|\*stack-trace-depth\*|\*state\*|\*testing-contexts\*|\*testing-vars\*|\*test-out\*|\*use-context-classloader\*|\*warn-on-reflection\*)\b/.exec(this.str)) && this.hl(m[0], 'dsKeyword;color:#b07e1f')) continue;
            if((m = /^(?:def|def-|defalias|defhinted|definline|defmacro|defmacro-|defmethod|defmulti|defn|defn-|defnk|defn-memo|defonce|defonce-|defprotocol|defrecord|defstruct|defstruct-|deftest|deftest-|deftype|defunbound|defunbound-|defvar|defvar-)\b/.exec(this.str)) && this.hl(m[0], 'dsKeyword;color:#d22811')) {if(m = this.clojure_function_decl())return this.pop(), m-1;continue;}
            if((m = /^\\./.exec(this.str)) && this.hl(m[0], 'dsChar')) continue;
            if(this.str[0] == '#' && this.str[1] == '"' && this.hl('#"', 'dsString')) {if(m = this.clojure_string())return this.pop(), m-1;continue;}
            if(this.str[0] == '"' && this.hl('"', 'dsString')) {if(m = this.clojure_string())return this.pop(), m-1;continue;}
            if((m = /^\d*\.\d+/.exec(this.str)) && this.hl(m[0], 'dsFloat')) continue;
            if((m = /^\d+/.exec(this.str)) && this.hl(m[0], 'dsDecVal')) continue;
            if(this.str[0] == '(' && this.hl('(', 'dsNormal;color:#ff0000;fontStyle:normal;fontWeight:normal')) {if(m = this.clojure_level1())return this.pop(), m-1;continue;}
            this.hl(this.str[0], 'dsNormal');
        }
        this.pop();
    },
    clojure_level2: function clojure_level2(m) {
        this.push();
        while(this.pos < this.len) {
            if(this.str[0] == '(' && this.hl('(', 'dsNormal;color:#888800;fontStyle:normal;fontWeight:normal')) {if(m = this.clojure_level3())return this.pop(), m-1;continue;}
            if(this.str[0] == '#' && this.str[1] == '(' && this.hl('#(', 'dsNormal;color:#888800;fontStyle:normal;fontWeight:normal')) {if(m = this.clojure_level3())return this.pop(), m-1;continue;}
            if(this.str[0] == ')' && this.hl(')', 'dsNormal;color:#ff8800;fontStyle:normal;fontWeight:normal')) return this.pop();
            if((m = /^;.*(?=$|\n)/.exec(this.str)) && this.hl(m[0], 'dsComment')) continue;
            if(this.str[0] == '#' && this.str[1] == '_' && this.hl('#_', 'dsComment')) continue;
            if((m = /^[@~]\S+/.exec(this.str)) && this.hl(m[0], 'dsKeyword;color:#800000')) continue;
            if((m = /^::?[a-zA-Z0-9\-]+/.exec(this.str)) && this.hl(m[0], 'dsKeyword;color:#555555')) continue;
            if(this.str[0] == '#' && this.str[1] == '{' && this.hl('#{', 'dsNormal;color:#0000ff;fontStyle:normal;fontWeight:bold')) continue;
            if(this.str[0] == '^' && this.str[1] == '{' && this.hl('^{', 'dsNormal;color:#0000ff;fontStyle:normal;fontWeight:bold')) continue;
            if(this.str[0] == '{' && this.hl('{', 'dsNormal;color:#206620')) continue;
            if(this.str[0] == '}' && this.hl('}', 'dsNormal;color:#206620')) continue;
            if(this.str[0] == '[' && this.hl('[', 'dsNormal;color:#3333ff')) continue;
            if(this.str[0] == ']' && this.hl(']', 'dsNormal;color:#3333ff')) continue;
            if(this.str[0] == '#' && this.str[1] == '\'' && this.hl('#\'', 'dsKeyword;color:#b07e1f')) continue;
            if((m = /^(?:<|<=|=|==|>|>=|-|->|->>|\/|\.|\.\.|\*|\+|accessor|aclone|add-classpath|add-watcher|agent|agent-errors|aget|alength|alias|all-ns|alter|alter-meta!|alter-var-root|amap|ancestors|and|append-child|apply|apply-template|are|areduce|array-map|aset|aset-boolean|aset-byte|aset-char|aset-double|aset-float|aset-int|aset-long|aset-short|assert|assert-any|assert-expr|assert-predicate|assoc|assoc!|associative\?|assoc-in|atom|atom\?|attrs|await|await1|await-for|bases|bean|bigdec|bigint|binding|bit-and|bit-and-not|bit-clear|bit-flip|bit-not|bit-or|bit-set|bit-shift-left|bit-shift-right|bit-test|bit-xor|boolean|boolean-array|booleans|bound-fn|bound-fn\*|branch\?|butlast|byte|byte-array|bytes|case|cast|catch|char|char\?|char-array|char-escape-string|char-name-string|chars|children|chunk|chunk-append|chunk-buffer|chunk-cons|chunked-seq\?|chunk-first|chunk-next|chunk-rest|class|class\?|clear-agent-errors|clojure-version|coll\?|collection-tag|comment|commute|comp|comparator|compare|compare-and-set!|compile|complement|compose-fixtures|concat|cond|condp|conj|conj!|cons|constantly|construct-proxy|contains\?|content|content-handler|count|counted\?|create-ns|create-struct|cycle|dec|decimal\?|declare|delay|delay\?|deliver|deref|derive|descendants|destructure|difference|disj|disj!|dissoc|dissoc!|distinct|distinct\?|do|doall|doc|dorun|doseq|dosync|do-template|dotimes|doto|double|double-array|doubles|down|drop|drop-last|drop-while|e|edit|element|emit|emit-element|empty|empty\?|end\?|ensure|enumeration-seq|eval|even\?|every\?|extend|extenders|extend-protocol|extends\?|extend-type|false\?|ffirst|file-position|file-seq|filter|finally|find|find-doc|find-ns|find-var|first|float|float\?|float-array|floats|flush|fn|fn\?|fnext|for|force|format|function\?|future|future\?|future-call|future-cancel|future-cancelled\?|future-done\?|gen-and-load-class|gen-and-save-class|gen-class|gen-interface|gensym|get|get-child|get-child-count|get-in|get-method|get-possibly-unbound-var|get-proxy-class|get-thread-bindings|get-validator|handle|handler-case|hash|hash-map|hash-set|identical\?|identity|if|if-let|ifn\?|if-not|import|inc|inc-report-counter|index|init-proxy|in-ns|insert-child|insert-left|insert-right|inspect|inspect-table|inspect-tree|instance\?|int|int-array|integer\?|interleave|intern|interpose|intersection|into|into-array|ints|io!|is|isa\?|is-leaf|iterate|iterator-seq|join|join-fixtures|juxt|key|keys|keyword|keyword\?|keywordize-keys|last|lazy-cat|lazy-seq|left|leftmost|lefts|let|letfn|line-seq|list|list\*|list\?|list-model|list-provider|load|loaded-libs|load-file|load-reader|load-script|load-string|locking|long|long-array|longs|loop|macroexpand|macroexpand-1|macroexpand-all|main|make-array|make-hierarchy|make-node|map|map\?|mapcat|map-invert|max|max-key|memfn|memoize|merge|merge-with|meta|methods|method-sig|min|min-key|mod|name|namespace|neg\?|newline|next|nfirst|nil\?|nnext|node|not|not=|not-any\?|not-empty|not-every\?|ns|ns-aliases|ns-imports|ns-interns|ns-map|ns-name|ns-publics|ns-refers|ns-resolve|ns-unalias|ns-unmap|nth|nthnext|num|number\?|odd\?|or|parents|partial|partition|path|pcalls|peek|persistent!|pmap|pop|pop!|pop-thread-bindings|pos\?|postwalk|postwalk-demo|postwalk-replace|pr|prefer-method|prefers|prev|prewalk|prewalk-demo|prewalk-replace|primitives-classnames|print|print-cause-trace|print-ctor|print-doc|print-dup|printf|println|println-str|print-method|print-namespace-doc|print-simple|print-special-doc|print-stack-trace|print-str|print-throwable|print-trace-element|prn|prn-str|project|promise|proxy|proxy-call-with-super|proxy-mappings|proxy-name|proxy-super|pr-str|push-thread-bindings|pvalues|quot|rand|rand-int|range|ratio\?|rational\?|rationalize|read|read-line|read-string|recur|reduce|ref|refer|refer-clojure|ref-history-count|re-find|ref-max-history|ref-min-history|ref-set|re-groups|reify|release-pending-sends|rem|re-matcher|re-matches|remove|remove-method|remove-ns|remove-watcher|rename|rename-keys|re-pattern|repeat|repeatedly|repl|replace|repl-caught|repl-exception|replicate|repl-prompt|repl-read|report|require|re-seq|reset!|reset-meta!|resolve|rest|resultset-seq|reverse|reversible\?|right|rightmost|rights|root|rseq|rsubseq|run-all-tests|run-tests|satisfies\?|second|select|select-keys|send|send-off|seq|seq\?|seque|sequence|sequential\?|seq-zip|set|set\?|set-test|set-validator!|short|short-array|shorts|shutdown-agents|skip-if-eol|skip-whitespace|slurp|some|sort|sort-by|sorted\?|sorted-map|sorted-map-by|sorted-set|sorted-set-by|special-form-anchor|special-symbol\?|split-at|split-with|str|stream\?|string\?|stringify-keys|struct|struct-map|subs|subseq|subvec|successful\?|supers|swap!|symbol|symbol\?|sync|syntax-symbol-anchor|take|take-last|take-nth|take-while|test|test-all-vars|testing|testing-contexts-str|testing-vars-str|test-ns|test-var|the-ns|throw|time|to-array|to-array-2d|trampoline|transient|tree-seq|true\?|try|try-expr|type|unchecked-add|unchecked-dec|unchecked-divide|unchecked-inc|unchecked-multiply|unchecked-negate|unchecked-remainder|unchecked-subtract|underive|unimport|union|unquote|unquote-splicing|up|update-in|update-proxy|use|use-fixtures|val|vals|var\?|var-get|var-set|vary-meta|vec|vector|vector\?|walk|when|when-first|when-let|when-not|while|with-bindings|with-bindings\*|with-in-str|with-loading-context|with-local-vars|with-meta|with-open|with-out-str|with-precision|with-test|with-test-out|xml-seq|zero\?)\b/.exec(this.str)) && this.hl(m[0], 'dsKeyword')) continue;
            if((m = /^(?:\*1|\*2|\*3|\*agent\*|\*allow-unresolved-vars\*|\*assert\*|\*clojure-version\*|\*command-line-args\*|\*compile-files\*|\*compile-path\*|\*current\*|\*e|\*err\*|\*file\*|\*flush-on-newline\*|\*in\*|\*initial-report-counters\*|\*load-tests\*|\*macro-meta\*|\*math-context\*|\*ns\*|\*out\*|\*print-dup\*|\*print-length\*|\*print-level\*|\*print-meta\*|\*print-readably\*|\*read-eval\*|\*report-counters\*|\*sb\*|\*source-path\*|\*stack\*|\*stack-trace-depth\*|\*state\*|\*testing-contexts\*|\*testing-vars\*|\*test-out\*|\*use-context-classloader\*|\*warn-on-reflection\*)\b/.exec(this.str)) && this.hl(m[0], 'dsKeyword;color:#b07e1f')) continue;
            if((m = /^(?:def|def-|defalias|defhinted|definline|defmacro|defmacro-|defmethod|defmulti|defn|defn-|defnk|defn-memo|defonce|defonce-|defprotocol|defrecord|defstruct|defstruct-|deftest|deftest-|deftype|defunbound|defunbound-|defvar|defvar-)\b/.exec(this.str)) && this.hl(m[0], 'dsKeyword;color:#d22811')) {if(m = this.clojure_function_decl())return this.pop(), m-1;continue;}
            if((m = /^\\./.exec(this.str)) && this.hl(m[0], 'dsChar')) continue;
            if(this.str[0] == '#' && this.str[1] == '"' && this.hl('#"', 'dsString')) {if(m = this.clojure_string())return this.pop(), m-1;continue;}
            if(this.str[0] == '"' && this.hl('"', 'dsString')) {if(m = this.clojure_string())return this.pop(), m-1;continue;}
            if((m = /^\d*\.\d+/.exec(this.str)) && this.hl(m[0], 'dsFloat')) continue;
            if((m = /^\d+/.exec(this.str)) && this.hl(m[0], 'dsDecVal')) continue;
            if(this.str[0] == '(' && this.hl('(', 'dsNormal;color:#ff0000;fontStyle:normal;fontWeight:normal')) {if(m = this.clojure_level1())return this.pop(), m-1;continue;}
            this.hl(this.str[0], 'dsNormal');
        }
        this.pop();
    },
    clojure_level3: function clojure_level3(m) {
        this.push();
        while(this.pos < this.len) {
            if(this.str[0] == '(' && this.hl('(', 'dsNormal;color:#008800;fontStyle:normal;fontWeight:normal')) {if(m = this.clojure_level4())return this.pop(), m-1;continue;}
            if(this.str[0] == '#' && this.str[1] == '(' && this.hl('#(', 'dsNormal;color:#008800;fontStyle:normal;fontWeight:normal')) {if(m = this.clojure_level4())return this.pop(), m-1;continue;}
            if(this.str[0] == ')' && this.hl(')', 'dsNormal;color:#888800;fontStyle:normal;fontWeight:normal')) return this.pop();
            if((m = /^;.*(?=$|\n)/.exec(this.str)) && this.hl(m[0], 'dsComment')) continue;
            if(this.str[0] == '#' && this.str[1] == '_' && this.hl('#_', 'dsComment')) continue;
            if((m = /^[@~]\S+/.exec(this.str)) && this.hl(m[0], 'dsKeyword;color:#800000')) continue;
            if((m = /^::?[a-zA-Z0-9\-]+/.exec(this.str)) && this.hl(m[0], 'dsKeyword;color:#555555')) continue;
            if(this.str[0] == '#' && this.str[1] == '{' && this.hl('#{', 'dsNormal;color:#0000ff;fontStyle:normal;fontWeight:bold')) continue;
            if(this.str[0] == '^' && this.str[1] == '{' && this.hl('^{', 'dsNormal;color:#0000ff;fontStyle:normal;fontWeight:bold')) continue;
            if(this.str[0] == '{' && this.hl('{', 'dsNormal;color:#206620')) continue;
            if(this.str[0] == '}' && this.hl('}', 'dsNormal;color:#206620')) continue;
            if(this.str[0] == '[' && this.hl('[', 'dsNormal;color:#3333ff')) continue;
            if(this.str[0] == ']' && this.hl(']', 'dsNormal;color:#3333ff')) continue;
            if(this.str[0] == '#' && this.str[1] == '\'' && this.hl('#\'', 'dsKeyword;color:#b07e1f')) continue;
            if((m = /^(?:<|<=|=|==|>|>=|-|->|->>|\/|\.|\.\.|\*|\+|accessor|aclone|add-classpath|add-watcher|agent|agent-errors|aget|alength|alias|all-ns|alter|alter-meta!|alter-var-root|amap|ancestors|and|append-child|apply|apply-template|are|areduce|array-map|aset|aset-boolean|aset-byte|aset-char|aset-double|aset-float|aset-int|aset-long|aset-short|assert|assert-any|assert-expr|assert-predicate|assoc|assoc!|associative\?|assoc-in|atom|atom\?|attrs|await|await1|await-for|bases|bean|bigdec|bigint|binding|bit-and|bit-and-not|bit-clear|bit-flip|bit-not|bit-or|bit-set|bit-shift-left|bit-shift-right|bit-test|bit-xor|boolean|boolean-array|booleans|bound-fn|bound-fn\*|branch\?|butlast|byte|byte-array|bytes|case|cast|catch|char|char\?|char-array|char-escape-string|char-name-string|chars|children|chunk|chunk-append|chunk-buffer|chunk-cons|chunked-seq\?|chunk-first|chunk-next|chunk-rest|class|class\?|clear-agent-errors|clojure-version|coll\?|collection-tag|comment|commute|comp|comparator|compare|compare-and-set!|compile|complement|compose-fixtures|concat|cond|condp|conj|conj!|cons|constantly|construct-proxy|contains\?|content|content-handler|count|counted\?|create-ns|create-struct|cycle|dec|decimal\?|declare|delay|delay\?|deliver|deref|derive|descendants|destructure|difference|disj|disj!|dissoc|dissoc!|distinct|distinct\?|do|doall|doc|dorun|doseq|dosync|do-template|dotimes|doto|double|double-array|doubles|down|drop|drop-last|drop-while|e|edit|element|emit|emit-element|empty|empty\?|end\?|ensure|enumeration-seq|eval|even\?|every\?|extend|extenders|extend-protocol|extends\?|extend-type|false\?|ffirst|file-position|file-seq|filter|finally|find|find-doc|find-ns|find-var|first|float|float\?|float-array|floats|flush|fn|fn\?|fnext|for|force|format|function\?|future|future\?|future-call|future-cancel|future-cancelled\?|future-done\?|gen-and-load-class|gen-and-save-class|gen-class|gen-interface|gensym|get|get-child|get-child-count|get-in|get-method|get-possibly-unbound-var|get-proxy-class|get-thread-bindings|get-validator|handle|handler-case|hash|hash-map|hash-set|identical\?|identity|if|if-let|ifn\?|if-not|import|inc|inc-report-counter|index|init-proxy|in-ns|insert-child|insert-left|insert-right|inspect|inspect-table|inspect-tree|instance\?|int|int-array|integer\?|interleave|intern|interpose|intersection|into|into-array|ints|io!|is|isa\?|is-leaf|iterate|iterator-seq|join|join-fixtures|juxt|key|keys|keyword|keyword\?|keywordize-keys|last|lazy-cat|lazy-seq|left|leftmost|lefts|let|letfn|line-seq|list|list\*|list\?|list-model|list-provider|load|loaded-libs|load-file|load-reader|load-script|load-string|locking|long|long-array|longs|loop|macroexpand|macroexpand-1|macroexpand-all|main|make-array|make-hierarchy|make-node|map|map\?|mapcat|map-invert|max|max-key|memfn|memoize|merge|merge-with|meta|methods|method-sig|min|min-key|mod|name|namespace|neg\?|newline|next|nfirst|nil\?|nnext|node|not|not=|not-any\?|not-empty|not-every\?|ns|ns-aliases|ns-imports|ns-interns|ns-map|ns-name|ns-publics|ns-refers|ns-resolve|ns-unalias|ns-unmap|nth|nthnext|num|number\?|odd\?|or|parents|partial|partition|path|pcalls|peek|persistent!|pmap|pop|pop!|pop-thread-bindings|pos\?|postwalk|postwalk-demo|postwalk-replace|pr|prefer-method|prefers|prev|prewalk|prewalk-demo|prewalk-replace|primitives-classnames|print|print-cause-trace|print-ctor|print-doc|print-dup|printf|println|println-str|print-method|print-namespace-doc|print-simple|print-special-doc|print-stack-trace|print-str|print-throwable|print-trace-element|prn|prn-str|project|promise|proxy|proxy-call-with-super|proxy-mappings|proxy-name|proxy-super|pr-str|push-thread-bindings|pvalues|quot|rand|rand-int|range|ratio\?|rational\?|rationalize|read|read-line|read-string|recur|reduce|ref|refer|refer-clojure|ref-history-count|re-find|ref-max-history|ref-min-history|ref-set|re-groups|reify|release-pending-sends|rem|re-matcher|re-matches|remove|remove-method|remove-ns|remove-watcher|rename|rename-keys|re-pattern|repeat|repeatedly|repl|replace|repl-caught|repl-exception|replicate|repl-prompt|repl-read|report|require|re-seq|reset!|reset-meta!|resolve|rest|resultset-seq|reverse|reversible\?|right|rightmost|rights|root|rseq|rsubseq|run-all-tests|run-tests|satisfies\?|second|select|select-keys|send|send-off|seq|seq\?|seque|sequence|sequential\?|seq-zip|set|set\?|set-test|set-validator!|short|short-array|shorts|shutdown-agents|skip-if-eol|skip-whitespace|slurp|some|sort|sort-by|sorted\?|sorted-map|sorted-map-by|sorted-set|sorted-set-by|special-form-anchor|special-symbol\?|split-at|split-with|str|stream\?|string\?|stringify-keys|struct|struct-map|subs|subseq|subvec|successful\?|supers|swap!|symbol|symbol\?|sync|syntax-symbol-anchor|take|take-last|take-nth|take-while|test|test-all-vars|testing|testing-contexts-str|testing-vars-str|test-ns|test-var|the-ns|throw|time|to-array|to-array-2d|trampoline|transient|tree-seq|true\?|try|try-expr|type|unchecked-add|unchecked-dec|unchecked-divide|unchecked-inc|unchecked-multiply|unchecked-negate|unchecked-remainder|unchecked-subtract|underive|unimport|union|unquote|unquote-splicing|up|update-in|update-proxy|use|use-fixtures|val|vals|var\?|var-get|var-set|vary-meta|vec|vector|vector\?|walk|when|when-first|when-let|when-not|while|with-bindings|with-bindings\*|with-in-str|with-loading-context|with-local-vars|with-meta|with-open|with-out-str|with-precision|with-test|with-test-out|xml-seq|zero\?)\b/.exec(this.str)) && this.hl(m[0], 'dsKeyword')) continue;
            if((m = /^(?:\*1|\*2|\*3|\*agent\*|\*allow-unresolved-vars\*|\*assert\*|\*clojure-version\*|\*command-line-args\*|\*compile-files\*|\*compile-path\*|\*current\*|\*e|\*err\*|\*file\*|\*flush-on-newline\*|\*in\*|\*initial-report-counters\*|\*load-tests\*|\*macro-meta\*|\*math-context\*|\*ns\*|\*out\*|\*print-dup\*|\*print-length\*|\*print-level\*|\*print-meta\*|\*print-readably\*|\*read-eval\*|\*report-counters\*|\*sb\*|\*source-path\*|\*stack\*|\*stack-trace-depth\*|\*state\*|\*testing-contexts\*|\*testing-vars\*|\*test-out\*|\*use-context-classloader\*|\*warn-on-reflection\*)\b/.exec(this.str)) && this.hl(m[0], 'dsKeyword;color:#b07e1f')) continue;
            if((m = /^(?:def|def-|defalias|defhinted|definline|defmacro|defmacro-|defmethod|defmulti|defn|defn-|defnk|defn-memo|defonce|defonce-|defprotocol|defrecord|defstruct|defstruct-|deftest|deftest-|deftype|defunbound|defunbound-|defvar|defvar-)\b/.exec(this.str)) && this.hl(m[0], 'dsKeyword;color:#d22811')) {if(m = this.clojure_function_decl())return this.pop(), m-1;continue;}
            if((m = /^\\./.exec(this.str)) && this.hl(m[0], 'dsChar')) continue;
            if(this.str[0] == '#' && this.str[1] == '"' && this.hl('#"', 'dsString')) {if(m = this.clojure_string())return this.pop(), m-1;continue;}
            if(this.str[0] == '"' && this.hl('"', 'dsString')) {if(m = this.clojure_string())return this.pop(), m-1;continue;}
            if((m = /^\d*\.\d+/.exec(this.str)) && this.hl(m[0], 'dsFloat')) continue;
            if((m = /^\d+/.exec(this.str)) && this.hl(m[0], 'dsDecVal')) continue;
            if(this.str[0] == '(' && this.hl('(', 'dsNormal;color:#ff0000;fontStyle:normal;fontWeight:normal')) {if(m = this.clojure_level1())return this.pop(), m-1;continue;}
            this.hl(this.str[0], 'dsNormal');
        }
        this.pop();
    },
    clojure_level4: function clojure_level4(m) {
        this.push();
        while(this.pos < this.len) {
            if(this.str[0] == '(' && this.hl('(', 'dsNormal;color:#000088;fontStyle:normal;fontWeight:normal')) {if(m = this.clojure_level5())return this.pop(), m-1;continue;}
            if(this.str[0] == '#' && this.str[1] == '(' && this.hl('#(', 'dsNormal;color:#000088;fontStyle:normal;fontWeight:normal')) {if(m = this.clojure_level5())return this.pop(), m-1;continue;}
            if(this.str[0] == ')' && this.hl(')', 'dsNormal;color:#008800;fontStyle:normal;fontWeight:normal')) return this.pop();
            if((m = /^;.*(?=$|\n)/.exec(this.str)) && this.hl(m[0], 'dsComment')) continue;
            if(this.str[0] == '#' && this.str[1] == '_' && this.hl('#_', 'dsComment')) continue;
            if((m = /^[@~]\S+/.exec(this.str)) && this.hl(m[0], 'dsKeyword;color:#800000')) continue;
            if((m = /^::?[a-zA-Z0-9\-]+/.exec(this.str)) && this.hl(m[0], 'dsKeyword;color:#555555')) continue;
            if(this.str[0] == '#' && this.str[1] == '{' && this.hl('#{', 'dsNormal;color:#0000ff;fontStyle:normal;fontWeight:bold')) continue;
            if(this.str[0] == '^' && this.str[1] == '{' && this.hl('^{', 'dsNormal;color:#0000ff;fontStyle:normal;fontWeight:bold')) continue;
            if(this.str[0] == '{' && this.hl('{', 'dsNormal;color:#206620')) continue;
            if(this.str[0] == '}' && this.hl('}', 'dsNormal;color:#206620')) continue;
            if(this.str[0] == '[' && this.hl('[', 'dsNormal;color:#3333ff')) continue;
            if(this.str[0] == ']' && this.hl(']', 'dsNormal;color:#3333ff')) continue;
            if(this.str[0] == '#' && this.str[1] == '\'' && this.hl('#\'', 'dsKeyword;color:#b07e1f')) continue;
            if((m = /^(?:<|<=|=|==|>|>=|-|->|->>|\/|\.|\.\.|\*|\+|accessor|aclone|add-classpath|add-watcher|agent|agent-errors|aget|alength|alias|all-ns|alter|alter-meta!|alter-var-root|amap|ancestors|and|append-child|apply|apply-template|are|areduce|array-map|aset|aset-boolean|aset-byte|aset-char|aset-double|aset-float|aset-int|aset-long|aset-short|assert|assert-any|assert-expr|assert-predicate|assoc|assoc!|associative\?|assoc-in|atom|atom\?|attrs|await|await1|await-for|bases|bean|bigdec|bigint|binding|bit-and|bit-and-not|bit-clear|bit-flip|bit-not|bit-or|bit-set|bit-shift-left|bit-shift-right|bit-test|bit-xor|boolean|boolean-array|booleans|bound-fn|bound-fn\*|branch\?|butlast|byte|byte-array|bytes|case|cast|catch|char|char\?|char-array|char-escape-string|char-name-string|chars|children|chunk|chunk-append|chunk-buffer|chunk-cons|chunked-seq\?|chunk-first|chunk-next|chunk-rest|class|class\?|clear-agent-errors|clojure-version|coll\?|collection-tag|comment|commute|comp|comparator|compare|compare-and-set!|compile|complement|compose-fixtures|concat|cond|condp|conj|conj!|cons|constantly|construct-proxy|contains\?|content|content-handler|count|counted\?|create-ns|create-struct|cycle|dec|decimal\?|declare|delay|delay\?|deliver|deref|derive|descendants|destructure|difference|disj|disj!|dissoc|dissoc!|distinct|distinct\?|do|doall|doc|dorun|doseq|dosync|do-template|dotimes|doto|double|double-array|doubles|down|drop|drop-last|drop-while|e|edit|element|emit|emit-element|empty|empty\?|end\?|ensure|enumeration-seq|eval|even\?|every\?|extend|extenders|extend-protocol|extends\?|extend-type|false\?|ffirst|file-position|file-seq|filter|finally|find|find-doc|find-ns|find-var|first|float|float\?|float-array|floats|flush|fn|fn\?|fnext|for|force|format|function\?|future|future\?|future-call|future-cancel|future-cancelled\?|future-done\?|gen-and-load-class|gen-and-save-class|gen-class|gen-interface|gensym|get|get-child|get-child-count|get-in|get-method|get-possibly-unbound-var|get-proxy-class|get-thread-bindings|get-validator|handle|handler-case|hash|hash-map|hash-set|identical\?|identity|if|if-let|ifn\?|if-not|import|inc|inc-report-counter|index|init-proxy|in-ns|insert-child|insert-left|insert-right|inspect|inspect-table|inspect-tree|instance\?|int|int-array|integer\?|interleave|intern|interpose|intersection|into|into-array|ints|io!|is|isa\?|is-leaf|iterate|iterator-seq|join|join-fixtures|juxt|key|keys|keyword|keyword\?|keywordize-keys|last|lazy-cat|lazy-seq|left|leftmost|lefts|let|letfn|line-seq|list|list\*|list\?|list-model|list-provider|load|loaded-libs|load-file|load-reader|load-script|load-string|locking|long|long-array|longs|loop|macroexpand|macroexpand-1|macroexpand-all|main|make-array|make-hierarchy|make-node|map|map\?|mapcat|map-invert|max|max-key|memfn|memoize|merge|merge-with|meta|methods|method-sig|min|min-key|mod|name|namespace|neg\?|newline|next|nfirst|nil\?|nnext|node|not|not=|not-any\?|not-empty|not-every\?|ns|ns-aliases|ns-imports|ns-interns|ns-map|ns-name|ns-publics|ns-refers|ns-resolve|ns-unalias|ns-unmap|nth|nthnext|num|number\?|odd\?|or|parents|partial|partition|path|pcalls|peek|persistent!|pmap|pop|pop!|pop-thread-bindings|pos\?|postwalk|postwalk-demo|postwalk-replace|pr|prefer-method|prefers|prev|prewalk|prewalk-demo|prewalk-replace|primitives-classnames|print|print-cause-trace|print-ctor|print-doc|print-dup|printf|println|println-str|print-method|print-namespace-doc|print-simple|print-special-doc|print-stack-trace|print-str|print-throwable|print-trace-element|prn|prn-str|project|promise|proxy|proxy-call-with-super|proxy-mappings|proxy-name|proxy-super|pr-str|push-thread-bindings|pvalues|quot|rand|rand-int|range|ratio\?|rational\?|rationalize|read|read-line|read-string|recur|reduce|ref|refer|refer-clojure|ref-history-count|re-find|ref-max-history|ref-min-history|ref-set|re-groups|reify|release-pending-sends|rem|re-matcher|re-matches|remove|remove-method|remove-ns|remove-watcher|rename|rename-keys|re-pattern|repeat|repeatedly|repl|replace|repl-caught|repl-exception|replicate|repl-prompt|repl-read|report|require|re-seq|reset!|reset-meta!|resolve|rest|resultset-seq|reverse|reversible\?|right|rightmost|rights|root|rseq|rsubseq|run-all-tests|run-tests|satisfies\?|second|select|select-keys|send|send-off|seq|seq\?|seque|sequence|sequential\?|seq-zip|set|set\?|set-test|set-validator!|short|short-array|shorts|shutdown-agents|skip-if-eol|skip-whitespace|slurp|some|sort|sort-by|sorted\?|sorted-map|sorted-map-by|sorted-set|sorted-set-by|special-form-anchor|special-symbol\?|split-at|split-with|str|stream\?|string\?|stringify-keys|struct|struct-map|subs|subseq|subvec|successful\?|supers|swap!|symbol|symbol\?|sync|syntax-symbol-anchor|take|take-last|take-nth|take-while|test|test-all-vars|testing|testing-contexts-str|testing-vars-str|test-ns|test-var|the-ns|throw|time|to-array|to-array-2d|trampoline|transient|tree-seq|true\?|try|try-expr|type|unchecked-add|unchecked-dec|unchecked-divide|unchecked-inc|unchecked-multiply|unchecked-negate|unchecked-remainder|unchecked-subtract|underive|unimport|union|unquote|unquote-splicing|up|update-in|update-proxy|use|use-fixtures|val|vals|var\?|var-get|var-set|vary-meta|vec|vector|vector\?|walk|when|when-first|when-let|when-not|while|with-bindings|with-bindings\*|with-in-str|with-loading-context|with-local-vars|with-meta|with-open|with-out-str|with-precision|with-test|with-test-out|xml-seq|zero\?)\b/.exec(this.str)) && this.hl(m[0], 'dsKeyword')) continue;
            if((m = /^(?:\*1|\*2|\*3|\*agent\*|\*allow-unresolved-vars\*|\*assert\*|\*clojure-version\*|\*command-line-args\*|\*compile-files\*|\*compile-path\*|\*current\*|\*e|\*err\*|\*file\*|\*flush-on-newline\*|\*in\*|\*initial-report-counters\*|\*load-tests\*|\*macro-meta\*|\*math-context\*|\*ns\*|\*out\*|\*print-dup\*|\*print-length\*|\*print-level\*|\*print-meta\*|\*print-readably\*|\*read-eval\*|\*report-counters\*|\*sb\*|\*source-path\*|\*stack\*|\*stack-trace-depth\*|\*state\*|\*testing-contexts\*|\*testing-vars\*|\*test-out\*|\*use-context-classloader\*|\*warn-on-reflection\*)\b/.exec(this.str)) && this.hl(m[0], 'dsKeyword;color:#b07e1f')) continue;
            if((m = /^(?:def|def-|defalias|defhinted|definline|defmacro|defmacro-|defmethod|defmulti|defn|defn-|defnk|defn-memo|defonce|defonce-|defprotocol|defrecord|defstruct|defstruct-|deftest|deftest-|deftype|defunbound|defunbound-|defvar|defvar-)\b/.exec(this.str)) && this.hl(m[0], 'dsKeyword;color:#d22811')) {if(m = this.clojure_function_decl())return this.pop(), m-1;continue;}
            if((m = /^\\./.exec(this.str)) && this.hl(m[0], 'dsChar')) continue;
            if(this.str[0] == '#' && this.str[1] == '"' && this.hl('#"', 'dsString')) {if(m = this.clojure_string())return this.pop(), m-1;continue;}
            if(this.str[0] == '"' && this.hl('"', 'dsString')) {if(m = this.clojure_string())return this.pop(), m-1;continue;}
            if((m = /^\d*\.\d+/.exec(this.str)) && this.hl(m[0], 'dsFloat')) continue;
            if((m = /^\d+/.exec(this.str)) && this.hl(m[0], 'dsDecVal')) continue;
            if(this.str[0] == '(' && this.hl('(', 'dsNormal;color:#ff0000;fontStyle:normal;fontWeight:normal')) {if(m = this.clojure_level1())return this.pop(), m-1;continue;}
            this.hl(this.str[0], 'dsNormal');
        }
        this.pop();
    },
    clojure_level5: function clojure_level5(m) {
        this.push();
        while(this.pos < this.len) {
            if(this.str[0] == '(' && this.hl('(', 'dsNormal;color:#880088;fontStyle:normal;fontWeight:normal')) {if(m = this.clojure_level6())return this.pop(), m-1;continue;}
            if(this.str[0] == '#' && this.str[1] == '(' && this.hl('#(', 'dsNormal;color:#880088;fontStyle:normal;fontWeight:normal')) {if(m = this.clojure_level6())return this.pop(), m-1;continue;}
            if(this.str[0] == ')' && this.hl(')', 'dsNormal;color:#000088;fontStyle:normal;fontWeight:normal')) return this.pop();
            if((m = /^;.*(?=$|\n)/.exec(this.str)) && this.hl(m[0], 'dsComment')) continue;
            if(this.str[0] == '#' && this.str[1] == '_' && this.hl('#_', 'dsComment')) continue;
            if((m = /^[@~]\S+/.exec(this.str)) && this.hl(m[0], 'dsKeyword;color:#800000')) continue;
            if((m = /^::?[a-zA-Z0-9\-]+/.exec(this.str)) && this.hl(m[0], 'dsKeyword;color:#555555')) continue;
            if(this.str[0] == '#' && this.str[1] == '{' && this.hl('#{', 'dsNormal;color:#0000ff;fontStyle:normal;fontWeight:bold')) continue;
            if(this.str[0] == '^' && this.str[1] == '{' && this.hl('^{', 'dsNormal;color:#0000ff;fontStyle:normal;fontWeight:bold')) continue;
            if(this.str[0] == '{' && this.hl('{', 'dsNormal;color:#206620')) continue;
            if(this.str[0] == '}' && this.hl('}', 'dsNormal;color:#206620')) continue;
            if(this.str[0] == '[' && this.hl('[', 'dsNormal;color:#3333ff')) continue;
            if(this.str[0] == ']' && this.hl(']', 'dsNormal;color:#3333ff')) continue;
            if(this.str[0] == '#' && this.str[1] == '\'' && this.hl('#\'', 'dsKeyword;color:#b07e1f')) continue;
            if((m = /^(?:<|<=|=|==|>|>=|-|->|->>|\/|\.|\.\.|\*|\+|accessor|aclone|add-classpath|add-watcher|agent|agent-errors|aget|alength|alias|all-ns|alter|alter-meta!|alter-var-root|amap|ancestors|and|append-child|apply|apply-template|are|areduce|array-map|aset|aset-boolean|aset-byte|aset-char|aset-double|aset-float|aset-int|aset-long|aset-short|assert|assert-any|assert-expr|assert-predicate|assoc|assoc!|associative\?|assoc-in|atom|atom\?|attrs|await|await1|await-for|bases|bean|bigdec|bigint|binding|bit-and|bit-and-not|bit-clear|bit-flip|bit-not|bit-or|bit-set|bit-shift-left|bit-shift-right|bit-test|bit-xor|boolean|boolean-array|booleans|bound-fn|bound-fn\*|branch\?|butlast|byte|byte-array|bytes|case|cast|catch|char|char\?|char-array|char-escape-string|char-name-string|chars|children|chunk|chunk-append|chunk-buffer|chunk-cons|chunked-seq\?|chunk-first|chunk-next|chunk-rest|class|class\?|clear-agent-errors|clojure-version|coll\?|collection-tag|comment|commute|comp|comparator|compare|compare-and-set!|compile|complement|compose-fixtures|concat|cond|condp|conj|conj!|cons|constantly|construct-proxy|contains\?|content|content-handler|count|counted\?|create-ns|create-struct|cycle|dec|decimal\?|declare|delay|delay\?|deliver|deref|derive|descendants|destructure|difference|disj|disj!|dissoc|dissoc!|distinct|distinct\?|do|doall|doc|dorun|doseq|dosync|do-template|dotimes|doto|double|double-array|doubles|down|drop|drop-last|drop-while|e|edit|element|emit|emit-element|empty|empty\?|end\?|ensure|enumeration-seq|eval|even\?|every\?|extend|extenders|extend-protocol|extends\?|extend-type|false\?|ffirst|file-position|file-seq|filter|finally|find|find-doc|find-ns|find-var|first|float|float\?|float-array|floats|flush|fn|fn\?|fnext|for|force|format|function\?|future|future\?|future-call|future-cancel|future-cancelled\?|future-done\?|gen-and-load-class|gen-and-save-class|gen-class|gen-interface|gensym|get|get-child|get-child-count|get-in|get-method|get-possibly-unbound-var|get-proxy-class|get-thread-bindings|get-validator|handle|handler-case|hash|hash-map|hash-set|identical\?|identity|if|if-let|ifn\?|if-not|import|inc|inc-report-counter|index|init-proxy|in-ns|insert-child|insert-left|insert-right|inspect|inspect-table|inspect-tree|instance\?|int|int-array|integer\?|interleave|intern|interpose|intersection|into|into-array|ints|io!|is|isa\?|is-leaf|iterate|iterator-seq|join|join-fixtures|juxt|key|keys|keyword|keyword\?|keywordize-keys|last|lazy-cat|lazy-seq|left|leftmost|lefts|let|letfn|line-seq|list|list\*|list\?|list-model|list-provider|load|loaded-libs|load-file|load-reader|load-script|load-string|locking|long|long-array|longs|loop|macroexpand|macroexpand-1|macroexpand-all|main|make-array|make-hierarchy|make-node|map|map\?|mapcat|map-invert|max|max-key|memfn|memoize|merge|merge-with|meta|methods|method-sig|min|min-key|mod|name|namespace|neg\?|newline|next|nfirst|nil\?|nnext|node|not|not=|not-any\?|not-empty|not-every\?|ns|ns-aliases|ns-imports|ns-interns|ns-map|ns-name|ns-publics|ns-refers|ns-resolve|ns-unalias|ns-unmap|nth|nthnext|num|number\?|odd\?|or|parents|partial|partition|path|pcalls|peek|persistent!|pmap|pop|pop!|pop-thread-bindings|pos\?|postwalk|postwalk-demo|postwalk-replace|pr|prefer-method|prefers|prev|prewalk|prewalk-demo|prewalk-replace|primitives-classnames|print|print-cause-trace|print-ctor|print-doc|print-dup|printf|println|println-str|print-method|print-namespace-doc|print-simple|print-special-doc|print-stack-trace|print-str|print-throwable|print-trace-element|prn|prn-str|project|promise|proxy|proxy-call-with-super|proxy-mappings|proxy-name|proxy-super|pr-str|push-thread-bindings|pvalues|quot|rand|rand-int|range|ratio\?|rational\?|rationalize|read|read-line|read-string|recur|reduce|ref|refer|refer-clojure|ref-history-count|re-find|ref-max-history|ref-min-history|ref-set|re-groups|reify|release-pending-sends|rem|re-matcher|re-matches|remove|remove-method|remove-ns|remove-watcher|rename|rename-keys|re-pattern|repeat|repeatedly|repl|replace|repl-caught|repl-exception|replicate|repl-prompt|repl-read|report|require|re-seq|reset!|reset-meta!|resolve|rest|resultset-seq|reverse|reversible\?|right|rightmost|rights|root|rseq|rsubseq|run-all-tests|run-tests|satisfies\?|second|select|select-keys|send|send-off|seq|seq\?|seque|sequence|sequential\?|seq-zip|set|set\?|set-test|set-validator!|short|short-array|shorts|shutdown-agents|skip-if-eol|skip-whitespace|slurp|some|sort|sort-by|sorted\?|sorted-map|sorted-map-by|sorted-set|sorted-set-by|special-form-anchor|special-symbol\?|split-at|split-with|str|stream\?|string\?|stringify-keys|struct|struct-map|subs|subseq|subvec|successful\?|supers|swap!|symbol|symbol\?|sync|syntax-symbol-anchor|take|take-last|take-nth|take-while|test|test-all-vars|testing|testing-contexts-str|testing-vars-str|test-ns|test-var|the-ns|throw|time|to-array|to-array-2d|trampoline|transient|tree-seq|true\?|try|try-expr|type|unchecked-add|unchecked-dec|unchecked-divide|unchecked-inc|unchecked-multiply|unchecked-negate|unchecked-remainder|unchecked-subtract|underive|unimport|union|unquote|unquote-splicing|up|update-in|update-proxy|use|use-fixtures|val|vals|var\?|var-get|var-set|vary-meta|vec|vector|vector\?|walk|when|when-first|when-let|when-not|while|with-bindings|with-bindings\*|with-in-str|with-loading-context|with-local-vars|with-meta|with-open|with-out-str|with-precision|with-test|with-test-out|xml-seq|zero\?)\b/.exec(this.str)) && this.hl(m[0], 'dsKeyword')) continue;
            if((m = /^(?:\*1|\*2|\*3|\*agent\*|\*allow-unresolved-vars\*|\*assert\*|\*clojure-version\*|\*command-line-args\*|\*compile-files\*|\*compile-path\*|\*current\*|\*e|\*err\*|\*file\*|\*flush-on-newline\*|\*in\*|\*initial-report-counters\*|\*load-tests\*|\*macro-meta\*|\*math-context\*|\*ns\*|\*out\*|\*print-dup\*|\*print-length\*|\*print-level\*|\*print-meta\*|\*print-readably\*|\*read-eval\*|\*report-counters\*|\*sb\*|\*source-path\*|\*stack\*|\*stack-trace-depth\*|\*state\*|\*testing-contexts\*|\*testing-vars\*|\*test-out\*|\*use-context-classloader\*|\*warn-on-reflection\*)\b/.exec(this.str)) && this.hl(m[0], 'dsKeyword;color:#b07e1f')) continue;
            if((m = /^(?:def|def-|defalias|defhinted|definline|defmacro|defmacro-|defmethod|defmulti|defn|defn-|defnk|defn-memo|defonce|defonce-|defprotocol|defrecord|defstruct|defstruct-|deftest|deftest-|deftype|defunbound|defunbound-|defvar|defvar-)\b/.exec(this.str)) && this.hl(m[0], 'dsKeyword;color:#d22811')) {if(m = this.clojure_function_decl())return this.pop(), m-1;continue;}
            if((m = /^\\./.exec(this.str)) && this.hl(m[0], 'dsChar')) continue;
            if(this.str[0] == '#' && this.str[1] == '"' && this.hl('#"', 'dsString')) {if(m = this.clojure_string())return this.pop(), m-1;continue;}
            if(this.str[0] == '"' && this.hl('"', 'dsString')) {if(m = this.clojure_string())return this.pop(), m-1;continue;}
            if((m = /^\d*\.\d+/.exec(this.str)) && this.hl(m[0], 'dsFloat')) continue;
            if((m = /^\d+/.exec(this.str)) && this.hl(m[0], 'dsDecVal')) continue;
            if(this.str[0] == '(' && this.hl('(', 'dsNormal;color:#ff0000;fontStyle:normal;fontWeight:normal')) {if(m = this.clojure_level1())return this.pop(), m-1;continue;}
            this.hl(this.str[0], 'dsNormal');
        }
        this.pop();
    },
    clojure_level6: function clojure_level6(m) {
        this.push();
        while(this.pos < this.len) {
            if(this.str[0] == '(' && this.hl('(', 'dsNormal;color:#ff0000;fontStyle:normal;fontWeight:normal')) {if(m = this.clojure_level1())return this.pop(), m-1;continue;}
            if(this.str[0] == '#' && this.str[1] == '(' && this.hl('#(', 'dsNormal;color:#ff0000;fontStyle:normal;fontWeight:normal')) {if(m = this.clojure_level1())return this.pop(), m-1;continue;}
            if(this.str[0] == ')' && this.hl(')', 'dsNormal;color:#880088;fontStyle:normal;fontWeight:normal')) return this.pop();
            if((m = /^;.*(?=$|\n)/.exec(this.str)) && this.hl(m[0], 'dsComment')) continue;
            if(this.str[0] == '#' && this.str[1] == '_' && this.hl('#_', 'dsComment')) continue;
            if((m = /^[@~]\S+/.exec(this.str)) && this.hl(m[0], 'dsKeyword;color:#800000')) continue;
            if((m = /^::?[a-zA-Z0-9\-]+/.exec(this.str)) && this.hl(m[0], 'dsKeyword;color:#555555')) continue;
            if(this.str[0] == '#' && this.str[1] == '{' && this.hl('#{', 'dsNormal;color:#0000ff;fontStyle:normal;fontWeight:bold')) continue;
            if(this.str[0] == '^' && this.str[1] == '{' && this.hl('^{', 'dsNormal;color:#0000ff;fontStyle:normal;fontWeight:bold')) continue;
            if(this.str[0] == '{' && this.hl('{', 'dsNormal;color:#206620')) continue;
            if(this.str[0] == '}' && this.hl('}', 'dsNormal;color:#206620')) continue;
            if(this.str[0] == '[' && this.hl('[', 'dsNormal;color:#3333ff')) continue;
            if(this.str[0] == ']' && this.hl(']', 'dsNormal;color:#3333ff')) continue;
            if(this.str[0] == '#' && this.str[1] == '\'' && this.hl('#\'', 'dsKeyword;color:#b07e1f')) continue;
            if((m = /^(?:<|<=|=|==|>|>=|-|->|->>|\/|\.|\.\.|\*|\+|accessor|aclone|add-classpath|add-watcher|agent|agent-errors|aget|alength|alias|all-ns|alter|alter-meta!|alter-var-root|amap|ancestors|and|append-child|apply|apply-template|are|areduce|array-map|aset|aset-boolean|aset-byte|aset-char|aset-double|aset-float|aset-int|aset-long|aset-short|assert|assert-any|assert-expr|assert-predicate|assoc|assoc!|associative\?|assoc-in|atom|atom\?|attrs|await|await1|await-for|bases|bean|bigdec|bigint|binding|bit-and|bit-and-not|bit-clear|bit-flip|bit-not|bit-or|bit-set|bit-shift-left|bit-shift-right|bit-test|bit-xor|boolean|boolean-array|booleans|bound-fn|bound-fn\*|branch\?|butlast|byte|byte-array|bytes|case|cast|catch|char|char\?|char-array|char-escape-string|char-name-string|chars|children|chunk|chunk-append|chunk-buffer|chunk-cons|chunked-seq\?|chunk-first|chunk-next|chunk-rest|class|class\?|clear-agent-errors|clojure-version|coll\?|collection-tag|comment|commute|comp|comparator|compare|compare-and-set!|compile|complement|compose-fixtures|concat|cond|condp|conj|conj!|cons|constantly|construct-proxy|contains\?|content|content-handler|count|counted\?|create-ns|create-struct|cycle|dec|decimal\?|declare|delay|delay\?|deliver|deref|derive|descendants|destructure|difference|disj|disj!|dissoc|dissoc!|distinct|distinct\?|do|doall|doc|dorun|doseq|dosync|do-template|dotimes|doto|double|double-array|doubles|down|drop|drop-last|drop-while|e|edit|element|emit|emit-element|empty|empty\?|end\?|ensure|enumeration-seq|eval|even\?|every\?|extend|extenders|extend-protocol|extends\?|extend-type|false\?|ffirst|file-position|file-seq|filter|finally|find|find-doc|find-ns|find-var|first|float|float\?|float-array|floats|flush|fn|fn\?|fnext|for|force|format|function\?|future|future\?|future-call|future-cancel|future-cancelled\?|future-done\?|gen-and-load-class|gen-and-save-class|gen-class|gen-interface|gensym|get|get-child|get-child-count|get-in|get-method|get-possibly-unbound-var|get-proxy-class|get-thread-bindings|get-validator|handle|handler-case|hash|hash-map|hash-set|identical\?|identity|if|if-let|ifn\?|if-not|import|inc|inc-report-counter|index|init-proxy|in-ns|insert-child|insert-left|insert-right|inspect|inspect-table|inspect-tree|instance\?|int|int-array|integer\?|interleave|intern|interpose|intersection|into|into-array|ints|io!|is|isa\?|is-leaf|iterate|iterator-seq|join|join-fixtures|juxt|key|keys|keyword|keyword\?|keywordize-keys|last|lazy-cat|lazy-seq|left|leftmost|lefts|let|letfn|line-seq|list|list\*|list\?|list-model|list-provider|load|loaded-libs|load-file|load-reader|load-script|load-string|locking|long|long-array|longs|loop|macroexpand|macroexpand-1|macroexpand-all|main|make-array|make-hierarchy|make-node|map|map\?|mapcat|map-invert|max|max-key|memfn|memoize|merge|merge-with|meta|methods|method-sig|min|min-key|mod|name|namespace|neg\?|newline|next|nfirst|nil\?|nnext|node|not|not=|not-any\?|not-empty|not-every\?|ns|ns-aliases|ns-imports|ns-interns|ns-map|ns-name|ns-publics|ns-refers|ns-resolve|ns-unalias|ns-unmap|nth|nthnext|num|number\?|odd\?|or|parents|partial|partition|path|pcalls|peek|persistent!|pmap|pop|pop!|pop-thread-bindings|pos\?|postwalk|postwalk-demo|postwalk-replace|pr|prefer-method|prefers|prev|prewalk|prewalk-demo|prewalk-replace|primitives-classnames|print|print-cause-trace|print-ctor|print-doc|print-dup|printf|println|println-str|print-method|print-namespace-doc|print-simple|print-special-doc|print-stack-trace|print-str|print-throwable|print-trace-element|prn|prn-str|project|promise|proxy|proxy-call-with-super|proxy-mappings|proxy-name|proxy-super|pr-str|push-thread-bindings|pvalues|quot|rand|rand-int|range|ratio\?|rational\?|rationalize|read|read-line|read-string|recur|reduce|ref|refer|refer-clojure|ref-history-count|re-find|ref-max-history|ref-min-history|ref-set|re-groups|reify|release-pending-sends|rem|re-matcher|re-matches|remove|remove-method|remove-ns|remove-watcher|rename|rename-keys|re-pattern|repeat|repeatedly|repl|replace|repl-caught|repl-exception|replicate|repl-prompt|repl-read|report|require|re-seq|reset!|reset-meta!|resolve|rest|resultset-seq|reverse|reversible\?|right|rightmost|rights|root|rseq|rsubseq|run-all-tests|run-tests|satisfies\?|second|select|select-keys|send|send-off|seq|seq\?|seque|sequence|sequential\?|seq-zip|set|set\?|set-test|set-validator!|short|short-array|shorts|shutdown-agents|skip-if-eol|skip-whitespace|slurp|some|sort|sort-by|sorted\?|sorted-map|sorted-map-by|sorted-set|sorted-set-by|special-form-anchor|special-symbol\?|split-at|split-with|str|stream\?|string\?|stringify-keys|struct|struct-map|subs|subseq|subvec|successful\?|supers|swap!|symbol|symbol\?|sync|syntax-symbol-anchor|take|take-last|take-nth|take-while|test|test-all-vars|testing|testing-contexts-str|testing-vars-str|test-ns|test-var|the-ns|throw|time|to-array|to-array-2d|trampoline|transient|tree-seq|true\?|try|try-expr|type|unchecked-add|unchecked-dec|unchecked-divide|unchecked-inc|unchecked-multiply|unchecked-negate|unchecked-remainder|unchecked-subtract|underive|unimport|union|unquote|unquote-splicing|up|update-in|update-proxy|use|use-fixtures|val|vals|var\?|var-get|var-set|vary-meta|vec|vector|vector\?|walk|when|when-first|when-let|when-not|while|with-bindings|with-bindings\*|with-in-str|with-loading-context|with-local-vars|with-meta|with-open|with-out-str|with-precision|with-test|with-test-out|xml-seq|zero\?)\b/.exec(this.str)) && this.hl(m[0], 'dsKeyword')) continue;
            if((m = /^(?:\*1|\*2|\*3|\*agent\*|\*allow-unresolved-vars\*|\*assert\*|\*clojure-version\*|\*command-line-args\*|\*compile-files\*|\*compile-path\*|\*current\*|\*e|\*err\*|\*file\*|\*flush-on-newline\*|\*in\*|\*initial-report-counters\*|\*load-tests\*|\*macro-meta\*|\*math-context\*|\*ns\*|\*out\*|\*print-dup\*|\*print-length\*|\*print-level\*|\*print-meta\*|\*print-readably\*|\*read-eval\*|\*report-counters\*|\*sb\*|\*source-path\*|\*stack\*|\*stack-trace-depth\*|\*state\*|\*testing-contexts\*|\*testing-vars\*|\*test-out\*|\*use-context-classloader\*|\*warn-on-reflection\*)\b/.exec(this.str)) && this.hl(m[0], 'dsKeyword;color:#b07e1f')) continue;
            if((m = /^(?:def|def-|defalias|defhinted|definline|defmacro|defmacro-|defmethod|defmulti|defn|defn-|defnk|defn-memo|defonce|defonce-|defprotocol|defrecord|defstruct|defstruct-|deftest|deftest-|deftype|defunbound|defunbound-|defvar|defvar-)\b/.exec(this.str)) && this.hl(m[0], 'dsKeyword;color:#d22811')) {if(m = this.clojure_function_decl())return this.pop(), m-1;continue;}
            if((m = /^\\./.exec(this.str)) && this.hl(m[0], 'dsChar')) continue;
            if(this.str[0] == '#' && this.str[1] == '"' && this.hl('#"', 'dsString')) {if(m = this.clojure_string())return this.pop(), m-1;continue;}
            if(this.str[0] == '"' && this.hl('"', 'dsString')) {if(m = this.clojure_string())return this.pop(), m-1;continue;}
            if((m = /^\d*\.\d+/.exec(this.str)) && this.hl(m[0], 'dsFloat')) continue;
            if((m = /^\d+/.exec(this.str)) && this.hl(m[0], 'dsDecVal')) continue;
            if(this.str[0] == '(' && this.hl('(', 'dsNormal;color:#ff0000;fontStyle:normal;fontWeight:normal')) {if(m = this.clojure_level1())return this.pop(), m-1;continue;}
            this.hl(this.str[0], 'dsNormal');
        }
        this.pop();
    }
};
